// filepath: tests/helpers/test-reporter.js
// AI-Powered Test Reporter and Documentation Generator

import fs from 'fs';
import path from 'path';

export class AITestReporter {
  constructor() {
    this.testResults = [];
    this.startTime = new Date();
    this.reportDir = 'test-results/ai-reports';
    
    // Create report directory
    if (!fs.existsSync(this.reportDir)) {
      fs.mkdirSync(this.reportDir, { recursive: true });
    }
  }

  recordTest(testName, suite, status, duration, error, screenshots) {
    this.testResults.push({
      testName,
      suite,
      status, // 'passed', 'failed', 'skipped'
      duration,
      error,
      screenshots,
      timestamp: new Date().toISOString()
    });
  }

  generateMarkdownReport() {
    const endTime = new Date();
    const totalDuration = (endTime - this.startTime) / 1000;

    const passed = this.testResults.filter(t => t.status === 'passed').length;
    const failed = this.testResults.filter(t => t.status === 'failed').length;
    const skipped = this.testResults.filter(t => t.status === 'skipped').length;
    const total = this.testResults.length;

    let report = `# ğŸ¤– AI Automated Test Execution Report

**Generated:** ${endTime.toLocaleString()}
**Duration:** ${totalDuration.toFixed(2)} seconds
**Application:** GolfBuddy App
**Test Framework:** Playwright + AI Analysis

---

## ğŸ“Š Executive Summary

| Metric | Value | Status |
|--------|-------|--------|
| **Total Tests** | ${total} | - |
| **âœ… Passed** | ${passed} | ${this.getStatusEmoji(passed, total)} |
| **âŒ Failed** | ${failed} | ${this.getStatusEmoji(total - failed, total)} |
| **â­ï¸ Skipped** | ${skipped} | - |
| **Pass Rate** | ${((passed / total) * 100).toFixed(1)}% | ${this.getPassRateStatus(passed, total)} |

---

## ğŸ¯ Test Suites Overview

`;

    // Group by suite
    const suites = {};
    this.testResults.forEach(test => {
      if (!suites[test.suite]) {
        suites[test.suite] = [];
      }
      suites[test.suite].push(test);
    });

    Object.keys(suites).forEach(suiteName => {
      const tests = suites[suiteName];
      const suitePassed = tests.filter(t => t.status === 'passed').length;
      const suiteFailed = tests.filter(t => t.status === 'failed').length;

      report += `### ${suiteName}\n\n`;
      report += `**Status:** ${suiteFailed === 0 ? 'âœ… All Passed' : `âŒ ${suiteFailed} Failed`}\n`;
      report += `**Tests:** ${suitePassed}/${tests.length} passed\n\n`;

      report += `| Test | Status | Duration | Notes |\n`;
      report += `|------|--------|----------|-------|\n`;

      tests.forEach(test => {
        const statusIcon = test.status === 'passed' ? 'âœ…' : test.status === 'failed' ? 'âŒ' : 'â­ï¸';
        const duration = `${test.duration}ms`;
        const notes = test.error ? `âš ï¸ See details below` : '-';
        
        report += `| ${test.testName} | ${statusIcon} | ${duration} | ${notes} |\n`;
      });

      report += `\n`;
    });

    // Failed tests details
    const failedTests = this.testResults.filter(t => t.status === 'failed');
    if (failedTests.length > 0) {
      report += `---

## âŒ Failed Tests Details

`;

      failedTests.forEach((test, index) => {
        report += `### ${index + 1}. ${test.testName}

**Suite:** ${test.suite}
**Error:**
\`\`\`
${test.error || 'No error details available'}
\`\`\`

**Screenshots:**
${test.screenshots ? test.screenshots.map(s => `- ![Screenshot](${s})`).join('\n') : 'No screenshots captured'}

**Recommended Actions:**
${this.generateRecommendations(test)}

---

`;
      });
    }

    // AI Analysis
    report += `## ğŸ§  AI Analysis & Insights

${this.generateAIInsights(this.testResults)}

---

## ğŸ“‹ Next Steps

${this.generateNextSteps(passed, failed, total)}

---

## ğŸ“ Artifacts

- **Full HTML Report:** \`playwright-report/index.html\`
- **JSON Results:** \`test-results/results.json\`
- **Screenshots:** \`test-results/screenshots/\`
- **Videos:** \`test-results/videos/\`
- **This Report:** \`${this.reportDir}/test-report-${this.startTime.getTime()}.md\`

---

**Report Generated by:** AI Testing Agent  
**Framework:** Playwright + AI Analysis  
**Reference:** QA_TESTING_GUIDE.md
`;

    return report;
  }

  getStatusEmoji(passed, total) {
    const rate = passed / total;
    if (rate === 1) return 'ğŸŸ¢ Perfect';
    if (rate >= 0.9) return 'ğŸŸ¢ Excellent';
    if (rate >= 0.7) return 'ğŸŸ¡ Good';
    if (rate >= 0.5) return 'ğŸŸ  Needs Work';
    return 'ğŸ”´ Critical';
  }

  getPassRateStatus(passed, total) {
    const rate = (passed / total) * 100;
    if (rate === 100) return 'ğŸ‰ Perfect Score!';
    if (rate >= 90) return 'âœ… Excellent';
    if (rate >= 70) return 'âš ï¸ Acceptable';
    return 'âŒ Action Required';
  }

  generateRecommendations(test) {
    const recommendations = [];

    if (test.error) {
      if (test.error.includes('timeout')) {
        recommendations.push('- **Timeout Issue:** Element may be loading slowly. Consider increasing timeout or checking network performance.');
        recommendations.push('- Verify the selector is correct and the element exists in the DOM.');
      }
      if (test.error.includes('selector')) {
        recommendations.push('- **Selector Issue:** Element not found. The UI may have changed.');
        recommendations.push('- Review the page HTML and update selectors in `test-data.js`.');
      }
      if (test.error.includes('navigation')) {
        recommendations.push('- **Navigation Issue:** Page did not navigate as expected.');
        recommendations.push('- Check authentication state and route protection.');
      }
    }

    if (recommendations.length === 0) {
      recommendations.push('- Review test logs and screenshots for more details.');
      recommendations.push('- Manually test the feature to identify the root cause.');
    }

    return recommendations.join('\n');
  }

  generateAIInsights(results) {
    const insights = [];

    // Pattern detection
    const failedByType = {};
    results.filter(t => t.status === 'failed').forEach(test => {
      const suite = test.suite;
      failedByType[suite] = (failedByType[suite] || 0) + 1;
    });

    if (Object.keys(failedByType).length > 0) {
      insights.push('**ğŸ” Failure Patterns Detected:**\n');
      Object.keys(failedByType).forEach(suite => {
        insights.push(`- **${suite}**: ${failedByType[suite]} test(s) failed - May indicate issues in this feature area.`);
      });
    }

    // Performance analysis
    const slowTests = results.filter(t => t.duration > 10000);
    if (slowTests.length > 0) {
      insights.push(`\n**âš¡ Performance Concerns:**\n`);
      insights.push(`- ${slowTests.length} test(s) took longer than 10 seconds.`);
      insights.push(`- Consider investigating: ${slowTests.map(t => t.testName).join(', ')}`);
    }

    // Success patterns
    const successfulSuites = [...new Set(results.filter(t => t.status === 'passed').map(t => t.suite))];
    if (successfulSuites.length > 0) {
      insights.push(`\n**âœ… Stable Features:**\n`);
      insights.push(`- The following features are working well: ${successfulSuites.join(', ')}`);
    }

    if (insights.length === 0) {
      insights.push('No significant patterns detected. All systems functioning normally.');
    }

    return insights.join('\n');
  }

  generateNextSteps(passed, failed, total) {
    const steps = [];

    if (failed === 0) {
      steps.push('1. âœ… All tests passed! Application is ready for deployment.');
      steps.push('2. ğŸ“ Review test coverage and consider adding more edge cases.');
      steps.push('3. ğŸ”„ Schedule regular automated test runs (daily/weekly).');
    } else {
      steps.push(`1. âŒ Fix ${failed} failing test(s) before deployment.`);
      steps.push('2. ğŸ” Review failed test details and screenshots above.');
      steps.push('3. ğŸ› ï¸ Make necessary code fixes and re-run tests.');
      steps.push('4. ğŸ“‹ Update QA_TESTING_GUIDE.md if test scenarios need adjustment.');
    }

    if ((passed / total) < 0.9) {
      steps.push('5. âš ï¸ Pass rate below 90% - Consider manual QA review.');
    }

    return steps.join('\n');
  }

  saveReport() {
    const report = this.generateMarkdownReport();
    const filename = `test-report-${this.startTime.getTime()}.md`;
    const filepath = path.join(this.reportDir, filename);

    fs.writeFileSync(filepath, report);

    // Also save as latest
    const latestPath = path.join(this.reportDir, 'LATEST_TEST_REPORT.md');
    fs.writeFileSync(latestPath, report);

    console.log(`\nâœ… AI Test Report saved to: ${filepath}`);
    console.log(`ğŸ“„ Latest report: ${latestPath}\n`);

    return filepath;
  }

  generateJSONReport() {
    const report = {
      summary: {
        total: this.testResults.length,
        passed: this.testResults.filter(t => t.status === 'passed').length,
        failed: this.testResults.filter(t => t.status === 'failed').length,
        skipped: this.testResults.filter(t => t.status === 'skipped').length,
        startTime: this.startTime,
        endTime: new Date(),
        duration: (new Date() - this.startTime) / 1000
      },
      tests: this.testResults
    };

    const filepath = path.join(this.reportDir, `test-results-${this.startTime.getTime()}.json`);
    fs.writeFileSync(filepath, JSON.stringify(report, null, 2));

    return report;
  }
}
